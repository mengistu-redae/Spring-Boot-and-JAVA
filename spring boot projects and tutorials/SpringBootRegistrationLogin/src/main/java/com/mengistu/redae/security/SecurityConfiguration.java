package com.mengistu.redae.security;

import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityCustomizer;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;

import com.mengistu.redae.service.CustomUserDetailsService;

/*

    In Spring Security 5.7.0-M2 the WebSecurityConfigurerAdapter is deprecated, 
    as it is encouraged to move towards a component-based security configuration.
    This is reason why "deprecated" warning is seen below.
    
    So, instead of extending WebSecurityConfigurerAdapter and overriding methods for 
	configuring HttpSecurity and WebSecurity as in the old way - Now we need to declare 
	two beans of type SecurityFilterChain and WebSecurityCustomizer.

*/

/*
	"@EnableWebSecurity" allows Spring to find (it's a @Configuration and @Component ) and 
	automatically apply the class to the global WebSecurity . If we don't annotate any of 
	our class with @EnableWebSecurity still the application prompting for username and password.
*/

//@Configuration
//@EnableWebSecurity
public class SecurityConfiguration {

	@Autowired
	private DataSource dataSource;

	@Bean
	public UserDetailsService userDetailsService() {
		return new CustomUserDetailsService();
	}

	@Bean
	public BCryptPasswordEncoder passwordEncoder() {
		return new BCryptPasswordEncoder();
	}

	/*
	 * There are many authentication manager types based on user source:- 
	 * ~ DaoAuthenticationProvider 
	 * ~ JDBC or LDAP authentication 
	 * ~ In memory authentication
	 * 
	 * Authentication provider(manager) needs two things:- 
	 * ~ UserDetailsService for fetching user details and 
	 * ~ password encoder for encoding user password so that it can
	 *   compare it with the encoded password in the database
	 * 
	 */
	@Bean
	public DaoAuthenticationProvider authenticationProvider() {
		DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
		authProvider.setUserDetailsService(userDetailsService());
		authProvider.setPasswordEncoder(passwordEncoder());

		return authProvider;
	}

	/*
	 * NOTE:-
	 * 
	 * In any application the levels of security basically include two parts: 
	 * 1. Authenticating - Authentication verifies the identity of a user or service.
	 *    It is used for log-in functionality. 
	 * 2. Authorizing - authorization determines their access 
	 *    rights. It is determining user roles after log-in.
	 * 
	 * So, we put our authentication and authorization configurations in
	 * objects(beans):- 1. Authentication object --- used for authentication
	 * configurations 2. HttpSecurity object --- used for authorization
	 * configurations
	 * 
	 * How we get these objects(beans) is using the following classes:- ~
	 * AuthenticationManagerBuilder class to create the authentication object ~
	 * HttpSecurity class to create the authorization object
	 * 
	 * principal = current user
	 * 
	 * The HttpSecurity object lets us to list: ~ all the request paths (http
	 * requests going to controllers) ~ the access restrictions for each of these
	 * request paths and ~ the login-logout page configurations together with
	 * session and cookie catch clearing configs
	 * 
	 * To specify the request paths, we can use ant style path patterns if we don't
	 * want to specify each request path
	 * 
	 * 
	 * The HttpSecurity uses a series of filters to apply the authorization policies
	 * by method chaining. The method "authorizeRequest()" opens up the chain...
	 * which is to mean like - "authorize the following request paths that are going
	 * to be specified"
	 * 
	 * Since there are many options to login(form login, LDAP login, OAuth login
	 * ...), we can call the "formLogin()" method to specify we accept login from
	 * form which is the default one if we don't explicitly call it.
	 * 
	 * 
	 */

	@Bean
	public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
		return authConfig.getAuthenticationManager();
	}

	/*
	 * a user must login to see the list users page (URL /users) and other pages do
	 * not require authentication.
	 * 
	 * We also configure the default login page (generated by Spring Security) with
	 * the parameter name of the username field is email and the default success URL
	 * is /users – that means after successful login, the user will be redirected to
	 * the list users page.
	 * 
	 */

	@Bean
	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {

		/*
		 * CSRF stands for Cross-Site Request Forgery. It is an attack that forces an
		 * end user to execute unwanted actions on a web application in which they are
		 * currently authenticated.
		 * 
		 */

		http.authenticationProvider(authenticationProvider()) // to authenticate, we call authentication in here
			.csrf().disable() // disable CSRF for this application
			.authorizeRequests() // Allows restricting access based upon the
								 // HttpServletRequest using RequestMatcher implementations (i.e. via URL
								 // patterns)
								 // to the below chains
			.antMatchers("/login").permitAll() // allow any user requesting "/login" page
			.antMatchers("/users", "/settings/**").hasAnyRole("Admin", "USER") 
														// or hasAnyAuthority("Admin", "Editor", "Salesperson", "Shipper")
														// OR if we have one role, we can use:
														// hasRole("Admin") OR
														// hasAuthority("ADMIN")
			.anyRequest().authenticated() // any other request are allowed to any authenticated user
			.and()
			.formLogin() // selecting type of login i.e. login is not from LDAP or any else
			.loginPage("/login") // our own custom login page
			.usernameParameter("email").defaultSuccessUrl("/users").permitAll().and().rememberMe()
			.key("AbcdEfghIjklmNopQrsTuvXyz_0123456789").and().logout() // our own custom logout page
			.logoutSuccessUrl("/").permitAll();

		http.headers().frameOptions().sameOrigin();

		return http.build();
	}

	/*
	 * "WebSecurityCustomizer" is a functional interface and can therefore be used
	 * as the assignment target for a lambda expression or method reference.
	 * 
	 * Callback interface for customizing WebSecurity. Beans of this type will
	 * automatically be used by WebSecurityConfiguration to customize WebSecurity.
	 */
	@Bean
	public WebSecurityCustomizer webSecurityCustomizer() {

		// Performs the customizations on WebSecurity
		// "web" - the instance of WebSecurity to apply to customizations to
		return (web) -> web.ignoring().antMatchers("/images/**", "/js/**", "/webjars/**");
	}

}
